2013-12-26    <dyuret@ku.edu.tr>

	* dlib.h: Hash tables implemented.  Still ugly and general for
	loop not possible because of types being general.  Experiments
	show that the linear search idea does not make a difference for
	D_HMIN 0-16, slows down for D_HMIN > 16.  Counting bigrams on
	wsj.tok.gz (5187874 126170376 690948662) takes 35 seconds (5 secs
	zcat, 5 secs forline etc) and 212M memory.  Vocab size is 608467
	and uniq bigrams are 10755423.  Space is dominated by uniq
	bigrams, the total hash table space allocated is for 20252586
	bigrams (costing 8 bytes each), almost double the necessary
	amount.  test_bigram spends 16 bytes, test_symtable 8 bytes by
	using a symbol table.  Might be worth considering sparsehash for
	small tables, which could halve the memory.  Also might be worth
	experimenting with obstacks.  Should continue reimplementing
	features.pl in C.

2013-12-14    <dyuret@ku.edu.tr>

	* foreach_line: NULL seems to cause compiler problems, represent
	stdin with "".  Arbitrary limit on line length disturbing, could
	use GNU getline instead, which has a much nicer interface.  Two
	problems: we did not want to depend on GNU extensions (which can
	be solved by including getline code in dlib).  Also we added zlib
	support, which has gzgets but not gzgetline!  Better check the
	implementation of getline.

	OK, getline uses internals of the *FILE pointer.  A more portable
	implementation would be to base it on fgets.  However it turns out
	c99 does not even define popen!  It seems I will have to use
	_GNU_SOURCE after all?

	* sglib: Here is the philosophy behind sglib:
	let's take a program defining an array of two-dimensional points
	represented by their coordinates:

	struct point {
	   int x;
	   int y;
	} thePointArray[SIZE];

	and a macro defining lexicographical ordering on points:

	#define CMP_POINT(p1,p2) ((p1.x!=p2.x)?(p1.x-p2.x):(p1.y-p2.y))

	In such case the following line of code is sorting the array using
	heap sort:

	  SGLIB_ARRAY_SINGLE_HEAP_SORT(struct point, thePointArray, SIZE, CMP_POINT);

	Note that no pointers are involved in this implementation.

	This is great.  But it is ugly.  We'd like sort(thePointArray) if
	possible.  Also somebody needs to take care of malloc, resize
	etc.  What is the best way to do this for a hash?

	* dlib: Deniz's C library.  glib disappoints.  code blows up
	without error when hash and array sizes increase.  unacceptable.
	have to write my own version.  need hashes (symbols?) and dynamic
	arrays.  foreach macros and error mechanism.  code using dlib
	should be easy to read.  should not rely on gnu extensions,
	although it would be nice to have obstacks, error, malloc
	debugging, getline etc.  just the c99 or c11 standard, cannot do
	without declarations in code, stdint, bool seem useful etc.  aim
	no warnings with pedantic.  inspired by sglib, define most things
	as macros.  have documentation in dlib.h, avoid dlib.c if you can.


